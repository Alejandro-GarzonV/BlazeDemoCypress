"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tag = exports.parseTags = exports.parseOneTag = exports.decodeTagInfo = exports.encodeTagInfo = exports.removeTagsFromTitle = exports.parseInlineTags = exports.uniqTags = void 0;
const regexTagsNoReasons = '(@[^@ ()"\']+)';
const regexDiffQuotes = ['"', "'"].map(t => `(@[^@ ]+\\(${t}[^@${t}]+${t}(?:,\\s*${t}[^@${t}]+${t})*\\))`);
const tagsRegex = new RegExp(`${regexDiffQuotes.join('|')}|${regexTagsNoReasons}`, 'g');
const uniqTags = (arr) => {
    const stringifyTagObj = (o) => {
        return JSON.stringify({
            tags: o.tag,
            info: o.info,
        });
    };
    return arr.filter((obj, index, self) => {
        const indexCurrent = self.map(s => stringifyTagObj(s)).indexOf(stringifyTagObj(obj));
        return indexCurrent === index;
    });
};
exports.uniqTags = uniqTags;
const parseInlineTags = (title) => {
    return (0, exports.parseTags)(title).map(t => (Object.assign(Object.assign({}, t), { tag: t.tag.startsWith('@') ? t.tag : `@${t.tag}` })));
};
exports.parseInlineTags = parseInlineTags;
const removeTagsFromTitle = (str) => {
    let resultStr = str;
    const found = str === null || str === void 0 ? void 0 : str.match(tagsRegex);
    if (found != null) {
        // eslint-disable-next-line no-return-assign
        found.forEach(p => (resultStr = resultStr.replace(p, '')));
    }
    return resultStr.replace(/\s\s*/g, ' ').trim();
};
exports.removeTagsFromTitle = removeTagsFromTitle;
const searchParams = [
    {
        sym: "'",
        map: '%27',
    },
];
const encodeDecode = (str, isEncode) => {
    let newStr = str;
    searchParams.forEach(
    // eslint-disable-next-line no-return-assign
    t => (newStr = newStr.replace(new RegExp(`${isEncode ? t.sym : t.map}`, 'g'), isEncode ? t.map : t.sym)));
    return newStr;
};
const encodeTagInfo = (str) => encodeDecode(encodeURIComponent(str), true);
exports.encodeTagInfo = encodeTagInfo;
const decodeTagInfo = (str) => encodeDecode(decodeURIComponent(str), false);
exports.decodeTagInfo = decodeTagInfo;
const parseOneTag = (tg) => {
    const reasons = [];
    let tagResult = '';
    const regexpReasons = /\((.*)\)$/;
    const regexpTag = /^@([^(@]+)(?:\(|$)/;
    const reasonsMatch = tg.match(regexpReasons);
    if (reasonsMatch != null) {
        reasons.push(...reasonsMatch[1]
            .split(',')
            .map(p => p.replace(/^\s*"([^"]*)"\s*$/, '$1'))
            .map(p => p.replace(/^\s*'([^']*)'\s*$/, '$1'))
            .map(k => (0, exports.decodeTagInfo)(k)));
    }
    const tagMatch = tg.match(regexpTag);
    if (tagMatch != null) {
        // eslint-disable-next-line prefer-destructuring
        tagResult = tagMatch[1];
    }
    return {
        tag: tagResult,
        info: reasons,
    };
};
exports.parseOneTag = parseOneTag;
const parseTags = (str) => {
    const tags = [];
    const found = str === null || str === void 0 ? void 0 : str.match(tagsRegex);
    if (found != null) {
        tags.push(...found.map(p => (0, exports.parseOneTag)(p)));
    }
    return tags;
};
exports.parseTags = parseTags;
/**
 * Helper function to create tag with info, returns string
 * @param name tag name ex 'my'
 * @param info params array  ex
 * tag('@my', 'Issue1'); // creates '@my("Issue1")'
 *
 * info then can be used in scope of test
 * @example
 *
 * it('test', { tags: [ tag('issue', 'example of info') ] }, function () {
 *   const infoForIssue = this.test?.tags?.find(t => t?.tag === 'issue')?.info ?? '';
 *   cy.log(`${infoForIssue}`);
 * });
 */
const tag = (name, ...info) => {
    const encodedReasons = info.map(inf => (0, exports.encodeTagInfo)(inf));
    const reasonsSeparatedByComma = encodedReasons.map(r => `"${r}"`).join(',');
    const reasonsStr = encodedReasons.length > 0 ? `(${reasonsSeparatedByComma})` : '';
    return `@${name}${reasonsStr}`;
};
exports.tag = tag;
