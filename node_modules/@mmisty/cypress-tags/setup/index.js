"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerTags = exports.origins = void 0;
const tags_1 = require("../utils/tags");
const origins = () => ({
    originIt: it,
    originItOnly: it.only,
    originItSkip: it.skip,
    originDescribe: describe,
    originOnly: describe.only,
    originSkip: describe.skip,
});
exports.origins = origins;
const registerTags = () => {
    const showTagsInTitle = () => {
        return Cypress.env('cyTagsShowTagsInTitle') !== undefined
            ? Cypress.env('cyTagsShowTagsInTitle') === 'true' || Cypress.env('cyTagsShowTagsInTitle') === true
            : undefined;
    };
    const originals = (0, exports.origins)();
    const parseOwnTags = (testOrSuite) => {
        var _a;
        const objTags = (_a = testOrSuite._testConfig) === null || _a === void 0 ? void 0 : _a.tags;
        const tagsArr = objTags ? (typeof objTags === 'string' ? [objTags] : objTags) : [];
        const fromConfig = tagsArr.flatMap(t => {
            if (typeof t === 'string') {
                return (0, tags_1.parseInlineTags)(t);
            }
            if (t.tag && typeof t.tag === 'string') {
                return [Object.assign({ info: [] }, t)];
            }
            return [{ tag: 'unknown type of tag' }];
        });
        const inlineTagsTest = (0, tags_1.parseInlineTags)(testOrSuite.title);
        return (0, tags_1.uniqTags)([...fromConfig, ...inlineTagsTest]);
    };
    const parseAll = (testOrSuite, res) => {
        const allOwnTags = parseOwnTags(testOrSuite);
        res = [...res, ...allOwnTags];
        if (testOrSuite.parent) {
            return parseAll(testOrSuite.parent, res);
        }
        return (0, tags_1.uniqTags)(res);
    };
    const tagsLineForTitle = (tags) => {
        const infoChange = (inf) => (inf && inf.length > 0 ? `("${inf.join('","')}")` : '');
        const encodeWhenSpecialChars = (info) => {
            return infoChange(info === null || info === void 0 ? void 0 : info.map(t => {
                const pattern = /[$^%@`]/;
                return pattern.test(t) ? (0, tags_1.encodeTagInfo)(t) : t;
            }));
        };
        return tags.map(t => `${t.tag}${encodeWhenSpecialChars(t.info)}`).join(' ');
    };
    /**
     * Add tags to title when specific setting
     * @param rootSuite
     * @param setting
     */
    const suiteTitleChange = (rootSuite, setting) => {
        var _a;
        const suiteTags = parseAll(rootSuite, []);
        rootSuite.tags = (0, tags_1.uniqTags)([...suiteTags, ...((_a = rootSuite.tags) !== null && _a !== void 0 ? _a : [])]);
        if (setting.showTagsInTitle !== undefined) {
            const tagsLine = setting.showTagsInTitle && suiteTags.length > 0 ? ` ${tagsLineForTitle(suiteTags)}` : '';
            rootSuite.title = `${(0, tags_1.removeTagsFromTitle)(rootSuite.title)}${tagsLine}`;
        }
        for (const suite of rootSuite.suites) {
            suiteTitleChange(suite, setting);
        }
    };
    const testProcess = (test) => {
        var _a;
        test.tags = (0, tags_1.uniqTags)([...((_a = test.tags) !== null && _a !== void 0 ? _a : []), ...parseAll(test, [])]);
        if (showTagsInTitle() === undefined) {
            return;
        }
        const ownTags = parseOwnTags(test);
        const tagsLine = showTagsInTitle() && ownTags.length > 0 ? ` ${tagsLineForTitle(ownTags)}` : '';
        test.title = (0, tags_1.removeTagsFromTitle)(test.title) + tagsLine;
    };
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const itWithTagsByOrigin = origin => function itWithTags(...args) {
        const test = origin(...args);
        // for tests that doesn't have parent suite
        if (test.parent && test.parent.title === '' && !test.parent.parent) {
            testProcess(test);
        }
        return test;
    };
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const describeWithTagsByOrig = original => function describeWithTags(...args) {
        var _a;
        const suite = original(...args);
        // do only for root suite
        if (((_a = suite.parent) === null || _a === void 0 ? void 0 : _a.title) === '') {
            suite.eachTest((st) => {
                testProcess(st);
            });
            if (showTagsInTitle() !== undefined) {
                suiteTitleChange(suite, { showTagsInTitle: showTagsInTitle() });
            }
        }
        return suite;
    };
    const handleRetries = () => {
        const runner = Cypress.mocha.getRunner();
        let prevTest;
        runner
            .on('retry', test => {
            prevTest = test;
        })
            .on('test', (test) => {
            if (test._currentRetry > 0 && prevTest) {
                test.tags = prevTest.tags;
            }
            else {
                prevTest = undefined;
            }
        });
    };
    global.describe = describeWithTagsByOrig(originals.originDescribe);
    global.describe.only = describeWithTagsByOrig(originals.originOnly);
    global.describe.skip = describeWithTagsByOrig(originals.originSkip);
    global.it = itWithTagsByOrigin(originals.originIt);
    global.it.only = itWithTagsByOrigin(originals.originItOnly);
    global.it.skip = itWithTagsByOrigin(originals.originItSkip);
    handleRetries();
};
exports.registerTags = registerTags;
